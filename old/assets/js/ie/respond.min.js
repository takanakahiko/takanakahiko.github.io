/*! Respond.js v1.4.2: min/max-width media query polyfill
 * Copyright 2014 Scott Jehl
 * Licensed under MIT
 * http://j.mp/respondjs */

!(function(a) {
  'use strict'
  a.matchMedia =
    a.matchMedia ||
    (function(a) {
      let b
      const c = a.documentElement
      const d = c.firstElementChild || c.firstChild
      const e = a.createElement('body')
      const f = a.createElement('div')
      return (
        (f.id = 'mq-test-1'),
        (f.style.cssText = 'position:absolute;top:-100em'),
        (e.style.background = 'none'),
        e.appendChild(f),
        function(a) {
          return (
            (f.innerHTML =
              '&shy;<style media="' +
              a +
              '"> #mq-test-1 { width: 42px; }</style>'),
            c.insertBefore(e, d),
            (b = f.offsetWidth === 42),
            c.removeChild(e),
            { matches: b, media: a }
          )
        }
      )
    })(a.document)
})(this),
  (function(a) {
    'use strict'
    function b() {
      v(!0)
    }
    const c = {}
    ;(a.respond = c), (c.update = function() {})
    const d = []
    const e = (function() {
      let b = !1
      try {
        b = new a.XMLHttpRequest()
      } catch (c) {
        b = new a.ActiveXObject('Microsoft.XMLHTTP')
      }
      return function() {
        return b
      }
    })()
    const f = function(a, b) {
      const c = e()
      c &&
        (c.open('GET', a, !0),
        (c.onreadystatechange = function() {
          c.readyState !== 4 ||
            (c.status !== 200 && c.status !== 304) ||
            b(c.responseText)
        }),
        c.readyState !== 4 && c.send(null))
    }
    const g = function(a) {
      return a.replace(c.regex.minmaxwh, '').match(c.regex.other)
    }
    if (
      ((c.ajax = f),
      (c.queue = d),
      (c.unsupportedmq = g),
      (c.regex = {
        media: /@media[^\{]+\{([^\{\}]*\{[^\}\{]*\})+/gi,
        keyframes: /@(?:\-(?:o|moz|webkit)\-)?keyframes[^\{]+\{(?:[^\{\}]*\{[^\}\{]*\})+[^\}]*\}/gi,
        comments: /\/\*[^*]*\*+([^/][^*]*\*+)*\//gi,
        urls: /(url\()['"]?([^\/\)'"][^:\)'"]+)['"]?(\))/g,
        findStyles: /@media *([^\{]+)\{([\S\s]+?)$/,
        only: /(only\s+)?([a-zA-Z]+)\s?/,
        minw: /\(\s*min\-width\s*:\s*(\s*[0-9\.]+)(px|em)\s*\)/,
        maxw: /\(\s*max\-width\s*:\s*(\s*[0-9\.]+)(px|em)\s*\)/,
        minmaxwh: /\(\s*m(in|ax)\-(height|width)\s*:\s*(\s*[0-9\.]+)(px|em)\s*\)/gi,
        other: /\([^\)]*\)/g
      }),
      (c.mediaQueriesSupported =
        a.matchMedia &&
        a.matchMedia('only all') !== null &&
        a.matchMedia('only all').matches),
      !c.mediaQueriesSupported)
    ) {
      let h
      let i
      let j
      const k = a.document
      const l = k.documentElement
      const m = []
      const n = []
      const o = []
      const p = {}
      const q = 30
      const r = k.getElementsByTagName('head')[0] || l
      const s = k.getElementsByTagName('base')[0]
      const t = r.getElementsByTagName('link')
      const u = function() {
        let a
        const b = k.createElement('div')
        let c = k.body
        const d = l.style.fontSize
        const e = c && c.style.fontSize
        let f = !1
        return (
          (b.style.cssText = 'position:absolute;font-size:1em;width:1em'),
          c ||
            ((c = f = k.createElement('body')), (c.style.background = 'none')),
          (l.style.fontSize = '100%'),
          (c.style.fontSize = '100%'),
          c.appendChild(b),
          f && l.insertBefore(c, l.firstChild),
          (a = b.offsetWidth),
          f ? l.removeChild(c) : c.removeChild(b),
          (l.style.fontSize = d),
          e && (c.style.fontSize = e),
          (a = j = parseFloat(a))
        )
      }
      var v = function(b) {
        const c = 'clientWidth'
        const d = l[c]
        const e = (k.compatMode === 'CSS1Compat' && d) || k.body[c] || d
        const f = {}
        const g = t[t.length - 1]
        const p = new Date().getTime()
        if (b && h && q > p - h)
          return a.clearTimeout(i), (i = a.setTimeout(v, q)), void 0
        h = p
        for (const s in m)
          if (m.hasOwnProperty(s)) {
            const w = m[s]
            let x = w.minw
            let y = w.maxw
            const z = x === null
            const A = y === null
            const B = 'em'
            x && (x = parseFloat(x) * (x.indexOf(B) > -1 ? j || u() : 1)),
              y && (y = parseFloat(y) * (y.indexOf(B) > -1 ? j || u() : 1)),
              (w.hasquery && ((z && A) || !(z || e >= x) || !(A || y >= e))) ||
                (f[w.media] || (f[w.media] = []), f[w.media].push(n[w.rules]))
          }
        for (const C in o)
          o.hasOwnProperty(C) &&
            o[C] &&
            o[C].parentNode === r &&
            r.removeChild(o[C])
        o.length = 0
        for (const D in f)
          if (f.hasOwnProperty(D)) {
            const E = k.createElement('style')
            const F = f[D].join('\n')
            ;(E.type = 'text/css'),
              (E.media = D),
              r.insertBefore(E, g.nextSibling),
              E.styleSheet
                ? (E.styleSheet.cssText = F)
                : E.appendChild(k.createTextNode(F)),
              o.push(E)
          }
      }
      const w = function(a, b, d) {
        const e = a
          .replace(c.regex.comments, '')
          .replace(c.regex.keyframes, '')
          .match(c.regex.media)
        let f = (e && e.length) || 0
        b = b.substring(0, b.lastIndexOf('/'))
        const h = function(a) {
          return a.replace(c.regex.urls, '$1' + b + '$2$3')
        }
        const i = !f && d
        b.length && (b += '/'), i && (f = 1)
        for (let j = 0; f > j; j++) {
          var k, l, o, p
          i
            ? ((k = d), n.push(h(a)))
            : ((k = e[j].match(c.regex.findStyles) && RegExp.$1),
              n.push(RegExp.$2 && h(RegExp.$2))),
            (o = k.split(',')),
            (p = o.length)
          for (let q = 0; p > q; q++)
            (l = o[q]),
              g(l) ||
                m.push({
                  media:
                    (l.split('(')[0].match(c.regex.only) && RegExp.$2) || 'all',
                  rules: n.length - 1,
                  hasquery: l.indexOf('(') > -1,
                  minw:
                    l.match(c.regex.minw) &&
                    parseFloat(RegExp.$1) + (RegExp.$2 || ''),
                  maxw:
                    l.match(c.regex.maxw) &&
                    parseFloat(RegExp.$1) + (RegExp.$2 || '')
                })
        }
        v()
      }
      var x = function() {
        if (d.length) {
          const b = d.shift()
          f(b.href, function(c) {
            w(c, b.href, b.media),
              (p[b.href] = !0),
              a.setTimeout(function() {
                x()
              }, 0)
          })
        }
      }
      const y = function() {
        for (let b = 0; b < t.length; b++) {
          const c = t[b]
          let e = c.href
          const f = c.media
          const g = c.rel && c.rel.toLowerCase() === 'stylesheet'
          e &&
            g &&
            !p[e] &&
            (c.styleSheet && c.styleSheet.rawCssText
              ? (w(c.styleSheet.rawCssText, e, f), (p[e] = !0))
              : ((!/^([a-zA-Z:]*\/\/)/.test(e) && !s) ||
                  e.replace(RegExp.$1, '').split('/')[0] === a.location.host) &&
                (e.substring(0, 2) === '//' && (e = a.location.protocol + e),
                d.push({ href: e, media: f })))
        }
        x()
      }
      y(),
        (c.update = y),
        (c.getEmValue = u),
        a.addEventListener
          ? a.addEventListener('resize', b, !1)
          : a.attachEvent && a.attachEvent('onresize', b)
    }
  })(this)
